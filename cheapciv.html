<!DOCTYPE html>
<head>
    <style type="text/css">
        .context-menu {
            position: absolute;
            text-align: center;
            background: lightgray;
            border: 1px solid black;
        }

        .context-menu ul {
            padding: 0px;
            margin: 0px;
            min-width: 150px;
            list-style: none;
        }

        .context-menu ul li {
            padding-bottom: 7px;
            padding-top: 7px;
            border: 1px solid black;
        }

        .context-menu ul li a {
            text-decoration: none;
            color: black;
        }

        .context-menu ul li:hover {
            background: darkgray;
        }
    </style>
		
				
		<img id="model_Settler" src="images/model_Settler.png" hidden="hidden">
		<img id="model_Worker" src="images/model_Worker.png" hidden="hidden">
		<img id="model_Warrior" src="images/model_Warrior.png" hidden="hidden">
		
		<img id="new_img" hidden="hidden">
		<img id="new_img_highlighted" hidden="hidden">

</head>

<body>
<p id="fps" hidden="hidden">Change text here</p>
</body>

<canvas id="canvas" width="680" height="480" style="border:1px solid #000000; position:relative; left:24px; top:24px;"></canvas>
<br><br><br>
<button type="button" onclick="endTurn(civ0)">End Turn</button> 

<p id="turninfo">Turn: 1</p>
<p id="cityinfo">cityinfo</p>

<div id="contextMenu" class="context-menu" style="display:none">
    <ul id="cityactions">
            <li><a onclick="assignCitizens()">Assign Citizens</a></li>
            <li><a onclick="hurryProduction()">Hurry Production</a></li>
            <li><a onclick="setProduction(0)">make thing 0</a></li>
            <li><a onclick="setProduction(1)">make thing 1</a></li>
            <li><a onclick="setProduction(2)">make thing 2</a></li>
            <li><a onclick="setProduction(3)">make thing 3</a></li>
            <li><a onclick="setProduction(4)">make thing 4</a></li>
    </ul>
</div>

<div id="contextMenu_units" class="context-menu" style="display:none">
    <ul id="unitsontile">
			<li><a onclick="selectUnit()">unitsmenu placeholder</a></li>
    </ul>
</div>

<script>
//select unit: left click
//move unit: right click (to adjacent tile only)
//right click after selecting city to get menu

//document.getElementById("txt1").innerHTML = "new text";
var running = 0;
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var fpsOut = document.getElementById('fps');
var turninfo = document.getElementById('turninfo');
var cityinfo = document.getElementById('cityinfo');
var update_background = 1;
var canvas_width = canvas.width;
var canvas_height = canvas.height;
var background;

//images
const model_Settler = document.getElementById("model_Settler");
const model_Warrior = document.getElementById("model_Warrior");
const model_Worker = document.getElementById("model_Worker");
const models = {};

var next_unit_id = 0;
var next_city_id = 0;

const w = 48; //width of tile (48)
var numTilesX = 30; //inline and offset tiles are counted separately, so numTilesX = 12 gives 24 columns
var numTilesY = 30;
const ui_w = 250;
const ui_h = 100;
var numTilesX_oncanvas = Math.ceil(canvas_width/(1.41*w));
var scroll_rate = 10; //px per frame to scroll when mouse is at edge
const fontsize_ui = 12;
wrapX = 1; //wrap x so scrolling to edge of map wraps around back to other side

var turn = 1;
var keypressedonce = "none"; //key currently being pressed, set back to "none" after action is done
var leftclickevent;
var leftclicked = 0;
var rightclickevent;
var rightclicked = 0;
var just_used_units_menu = 0;
var mouseover_x = -1;
var mouseover_y = -1;


function randint(min,max) {
	return Math.floor(Math.random() * (max - min) + min);
}

class Unit {
  constructor(name, civ) {
    this.id = next_unit_id;
    next_unit_id += 1;
    this.name = name; //"warrior"
    this.civ = civ; //number
		this.active = 1; //1 to auto-select before ending turn, 0 if sleeping
		if (this.name === "Warrior") {
			this.type = "military_land"; //same types as in getMakingType
			this.atk = 1;
			this.def = 1;
			this.moves = 1; //moves allowed each turn
			this.shieldcost = 10; //in getShieldcost
			this.hp = 3; //max hp
			this.model = model_Warrior; //todo: model to display on map
			this.icon = 0; //todo: icon
		}
		if (this.name === "Settler") {
			this.type = "settler";
			this.atk = 0;
			this.def = 0;
			this.moves = 1; //moves allowed each turn
			this.shieldcost = 30;
			this.hp = 1; //max hp
			this.model = model_Settler; //todo: model to display on map
			this.icon = 0; //todo: icon
		}
		if (this.name === "Worker") {
			this.type = "worker";
			this.atk = 0;
			this.def = 0;
			this.moves = 1; //moves allowed each turn
			this.shieldcost = 10;
			this.hp = 1; //max hp
			this.model = model_Worker; //todo: model to display on map
			this.icon = 0; //todo: icon
		}
		this.hpleft = this.hp; //current hp
		this.movesleft = this.moves; //moves remaining this turn
		//this.x
		//this.y
  }
	buildCity() {
		if (0) { //todo: check if city location is valid
			return;
		}
		else {
			let _name = "new city zzz"; //todo: set city name here
			let _newcity = new City(_name, this.civ, "Settler", this.x, this.y);
			cities_map[this.y][this.x].push(_newcity);
			civs[this.civ].cities.push(_newcity);
			//delete unit			
			let _ind = units_map[this.y][this.x].findIndex( object => {return object.id === unit_selected.id;} ) //get index of selected unit in array of units on selected tile;
			units_map[this.y][this.x].splice(_ind, 1); //remove selected unit from tile
			//remove unit from civ's units
			let _ind2 = civs[this.civ].units.findIndex( object => {return object.id === unit_selected.id;} ) //get index of selected unit in array of units on selected tile;
			civs[this.civ].units.splice(_ind2, 1); //remove selected unit from old tile
		}
	}
	
	remove() { //remove from units_map[this.y][this.x] and civs[this.civ][units]
		let _ind = units_map[this.y][this.x].findIndex( object => {return object.id === this.id;} ) //get index of selected unit in array of units on selected tile;
		units_map[this.y][this.x].splice(_ind, 1); //remove selected unit from tile
		//remove unit from civ's units
		let _ind2 = civs[this.civ].units.findIndex( object => {return object.id === this.id;} ) //get index of selected unit in array of units on selected tile;
		civs[this.civ].units.splice(_ind2, 1); //remove selected unit from old tile
	}
	
	draw(_tileX, _tileY) { //draw on screen at (_tileX, _tileY)
		let img = models[this.model.id + this.civ];
		models; //global, needs to be called here for drawImage to work, idk why
		ctx.drawImage(img, _tileX + 0.1*w, _tileY);
	}
	
	draw_old(_tileX, _tileY) { //draw on screen at (_tileX, _tileY)
		//change some pixel values to get different colors
		//todo: create hidden image elements for each unit when civs are created
		
		//set r, b ==255 to transparent

		let _model = this.model;
		
		// create a destination canvas. Here the altered image will be placed
		//var dstCanvas = document.createElement("canvas");
		//dstCanvas.width = _model.width;
		//dstCanvas.height = _model.height;

		// append the canvas elements to the container
		//document.getElementById('container').appendChild(srcCanvas);
		//document.getElementById('container').appendChild(dstCanvas);

		// get context to work with
		var srcCanvas = document.createElement("canvas");
		srcCanvas.width = _model.width;
		srcCanvas.height = _model.height;
		var srcContext = srcCanvas.getContext("2d");
		//var dstContext = dstCanvas.getContext("2d");

		// draw the loaded image on the source canvas
		srcContext.drawImage(_model, 0, 0);

		// read pixels from source
		var pixels = srcContext.getImageData(0, 0, _model.width, _model.height);

		// iterate through pixel data (1 pixels consists of 4 ints in the array)
		for(var i = 0, len = pixels.data.length; i < len; i += 4){
				var r = pixels.data[i];
				var g = pixels.data[i+1];
				var b = pixels.data[i+2];

				// if the pixel matches color, set alpha to 0
				if(r == 255 && g == 0 && b == 255){
						pixels.data[i] = civs[this.civ].r;
						pixels.data[i+1] = civs[this.civ].g;
						pixels.data[i+2] = civs[this.civ].b;
				}
		}

		// write pixel data to destination context
		srcContext.putImageData(pixels, 0, 0);
		
		var img = document.getElementById("new_img");
		img.src = srcCanvas.toDataURL();
		
		ctx.drawImage(img, _tileX + 0.1*w, _tileY);
	}
	
	drawHighlighted(_tileX, _tileY) { //draw on screen at (_tileX, _tileY)
			//change some pixel values to get different colors
		//todo: create hidden image elements for each unit when civs are created
		
		//set r, b ==255 to transparent

		let _model = this.model;
		
		// create a destination canvas. Here the altered image will be placed
		//var dstCanvas = document.createElement("canvas");
		//dstCanvas.width = _model.width;
		//dstCanvas.height = _model.height;

		// append the canvas elements to the container
		//document.getElementById('container').appendChild(srcCanvas);
		//document.getElementById('container').appendChild(dstCanvas);

		// get context to work with
		let srcCanvas = document.createElement("canvas");
		srcCanvas.width = _model.width;
		srcCanvas.height = _model.height;
		let srcContext = srcCanvas.getContext("2d");
		//var dstContext = dstCanvas.getContext("2d");

		// draw the loaded image on the source canvas
		srcContext.drawImage(_model, 0, 0);

		// read pixels from source
		let pixels = srcContext.getImageData(0, 0, _model.width, _model.height);

		// iterate through pixel data (1 pixels consists of 4 ints in the array)
		for (let i = 0, len = pixels.data.length; i < len; i += 4){
				let r = pixels.data[i];
				let g = pixels.data[i+1];
				let b = pixels.data[i+2];
				let a = pixels.data[i+3];

				// if the pixel matches color, set alpha to 0
				if (r == 255 && g == 0 && b == 255){
					pixels.data[i] = civs[this.civ].r;
					pixels.data[i+1] = civs[this.civ].g;
					pixels.data[i+2] = civs[this.civ].b;
				}
				else if (a != 0) { //highlight non-transparent tiles by increasing rgb values
					let rn = pixels.data[i] + 40;
					let gn = pixels.data[i+1] + 40;
					let bn = pixels.data[i+2] + 40;
					if (rn > 255) {rn = 255;}
					if (gn > 255) {gn = 255;}
					if (bn > 255) {bn = 255;}
					pixels.data[i] = rn; pixels.data[i+1] = gn; pixels.data[i+2] = bn;
				}
		}

		// write pixel data to destination context
		srcContext.putImageData(pixels, 0, 0);
		
		let img = document.getElementById("new_img_highlighted");
		img.src = srcCanvas.toDataURL();
		
		ctx.drawImage(img, _tileX + 0.1*w, _tileY);
	}
	
}

class City {
  constructor(name, civ, making, x, y) {
    this.id = next_city_id;
		//location
		this.x = x;
		this.y = y;
    next_city_id += 1;
    this.name = name;
    this.civ = civ; //number (civobject.id or civs[civ])

		//resources
    this.food = 0; //current food income, calculated in this.updateCity()
    this.shields = 0; //current shield income
    this.trade = 0; //current trade income
		this.food_to_grow = 10;
		this.shields_to_make = 10;
		this.food_stored = 0;
		this.shields_stored = 0;
		this.corruption = 0;
		//citizen stuff
		this.population = 1;
		this.happy = 0;
		this.content = 1;
		this.angry = 0;
		this.entertainers = 0;
		this.tiles_worked = [0,0,1,0,0,0,0,0]; //used in drawCitizens(), will be used to calculate resources from cities each turn
		this.tiles_available = [1,1,1,1,1,1,1,1]; //same size as tiles_worked and tiles_adjacent, 1 for available, 0 for not available
		//buildings and production
		this.making = making;
		this.buildings = []; //names of buildings in this city
		this.production_list = ["Settler", "Worker", "Warrior", "Wealth"]; //stuff available to produce in this city
		this.updateCity();
	}
  
  citymenu(open,e=null) { //open=1 opens, open=0 closes; e is click event
    if (open == 1) {
      console.log("opening city menu for", this.name);
			
			let list = document.getElementById("cityactions");
			list.innerHTML = "";
			//add list elements to menu
			let li = document.createElement("li");
			li.innerText = "Assign Citizens";
			li.setAttribute("onclick", "assignCitizens()");
			list.appendChild(li);
			let li2 = document.createElement("li");
			li2.innerText = "Hurry Production";
			li2.setAttribute("onclick", "HurryProduction()");
			list.appendChild(li2);
			for (let i=0; i<this.production_list.length; i++) {
					let li = document.createElement("li");
					li.innerText = this.production_list[i];
					li.setAttribute("onclick", "setProduction(" + i + ")");
					list.appendChild(li);
			}
			
      let menu = document.getElementById("contextMenu");
      menu.style.display = "block";
      menu.style.left = e.pageX + "px";
      menu.style.top = e.pageY + "px"; 
		}
    else {
      console.log("closing city menu");
      let menu = document.getElementById("contextMenu");
      menu.style.display = "none";
    }
  }
	
	updateCity() { //update resources and happiness
		//todo: update number of content, happy, angry citizens based on population and entertainers
		this.content = this.population - this.entertainers;
		//update resources
		this.food = 2; this.shields = 2; this.trade = 1 + terrain_map[this.y][this.x].trade; //start with city tile
		let tiles_adjacent = getAdjacentTiles(this.y, this.x);
		let _x; let _y;
		for (let i=0; i<this.tiles_worked.length; i++) {
			if (this.tiles_worked[i] == 1) { //for every tile worked, add its resources
				[_y, _x] = tiles_adjacent[i]; //get tile indices of worked tile
				this.food += terrain_map[_y][_x].food;
				this.shields += terrain_map[_y][_x].shields;
				this.trade += terrain_map[_y][_x].trade;
			}
		}
		this.food -= 2*this.population; //2 food per citizen
		this.shields_to_make = getShieldcost(this.making);
	}
	
	updateTilesAvailable() {
		for (let i=0; i<this.tiles_available.length; i++) {
			//todo: check if tile is occupied by city or enemy unit
			this.tiles_available[i] = 1;
		}
	}
	
	setProduction(n) {
		console.log(this.production_list[n]);
		this.making = this.production_list[n];
		this.shields_to_make = getShieldcost(this.making);
		updateCityInfo(this);
	}
}

class Civ {
  constructor(id, rgb) {
    this.id = id; //int
    this.units = [];
		this.cities = [];
		this.r = rgb[0];
		this.g = rgb[1];
		this.b = rgb[2];
		this.color = numToColor(this.r,this.g,this.b);
		this.gold = 0;
		this.science = 0;
		//tax sliders
		this.taxrate = 0.2;
		this.sciencerate = 0.8;
		this.luxrate = 0.0;
  }
	highlight() { //get highlighted civ color
	let r = 1.3*this.r;
	let g = 1.3*this.g;
	let b = 1.3*this.b;
	if (r > 255) {r = 255;}
	if (g > 255) {g = 255;}
	if (b > 255) {b = 255;}
	return numToColor(r, g, b);
	}
}

class Terrain {
	constructor(id) {
		switch (id) { //grassland
			case 0:
				this.food = 2;
				this.shields = 0;
				this.trade = 0;
				this.can_mine = 1;
				this.can_irrigate = 1;
				this.can_chop = 0;
				this.r = 80;
				this.g = 255;
				this.b = 40;
				this.color = numToColor(this.r,this.g,this.b)
				break;
			case 1: //plains
				this.food = 1;
				this.shields = 1;
				this.trade = 0;
				this.can_mine = 1;
				this.can_irrigate = 1;
				this.can_chop = 0
				this.r = 255;
				this.g = 255;
				this.b = 40;
				this.color = numToColor(this.r,this.g,this.b)
				break;
			case 2: //mountain
				this.food = 0;
				this.shields = 2;
				this.trade = 0;
				this.can_mine = 1;
				this.can_irrigate = 0;
				this.can_chop = 0;
				this.r = 100;
				this.g = 80;
				this.b = 80;
				this.color = numToColor(this.r,this.g,this.b)
				break;
			case 3: //forest
				this.food = 1;
				this.shields = 2;
				this.trade = 0;
				this.can_mine = 0;
				this.can_irrigate = 0;
				this.can_chop = 1;
				this.r = 70;
				this.g = 150;
				this.b = 40;
				this.color = numToColor(this.r,this.g,this.b)
		}
		//improvements
		this.mined = 0;
		this.roaded = 0;
		this.irrigated = 0;
	}
}

//set up terrain array; todo: generate terrain
const terrain_map = [];
for (let y=0; y<numTilesY; y++) {
  terrain_map.push([]);
  for (let x=0; x<numTilesX+1; x++) {
    terrain_map[y].push(new Terrain( randint(0,4) ));
  }
}


//set up civs
const civ0 = new Civ(0,[50,50,200]);
const civ1 = new Civ(1,[200,50,50]);
const civs = [civ0,civ1];

//set up cities array
const cities_map = [];
for (let y=0; y<numTilesY; y++) {
  cities_map.push([]);
  for (let x=0; x<numTilesX+1; x++) {
    cities_map[y].push([]);
  }
}
//starting cities
const c0 = new City("Buttzville", 0, "Settler", 7, 13);
const c1 = new City("Clowntown", 1, "Settler", 2, 3);
const c2 = new City("Test City", 0, "Settler", 24, 7);
cities_map[c0.y][c0.x].push(c0); //[offset][y][x]
civ0.cities.push(c0);
cities_map[c1.y][c1.x].push(c1);
civ1.cities.push(c1);
cities_map[c2.y][c2.x].push(c2);
civ0.cities.push(c2);

//set up units array
const units_map = [];
for (let y=0; y<numTilesY; y++) {
  units_map.push([]);
  for (let x=0; x<numTilesX+1; x++) {
    units_map[y].push([]); //array in each tile, will contain unit objects
  }
}




//starting units
const u0 = new Unit("Warrior", 0);
u0.x = 7; u0.y = 5;
civs[u0.civ].units.push(u0);
units_map[u0.y][u0.x].push(u0);

const u1 = new Unit("Warrior", 1);
u1.x = 13; u1.y = 6;
civs[u1.civ].units.push(u1);
units_map[u1.y][u1.x].push(u1);

const u2 = new Unit("Settler", 0);
u2.x = 7; u2.y = 5;
civs[u2.civ].units.push(u2);
units_map[u2.y][u2.x].push(u2);

const u3 = new Unit("Warrior", 0);
u3.x = 13; u3.y = 5;
civs[u3.civ].units.push(u3);
units_map[u3.y][u3.x].push(u3);

const u4 = new Unit("Warrior", 1);
u4.x = 13; u4.y = 6;
civs[u4.civ].units.push(u4);
units_map[u4.y][u4.x].push(u4);

const u5 = new Unit("Warrior", 1);
u5.x = 13; u5.y = 6;
civs[u5.civ].units.push(u5);
units_map[u5.y][u5.x].push(u5);

//constants
const MOUSE_SELECT = 0;
const MOUSE_MOVE = 1;
const MOUSE_MENU = 2;
const civ_PC = 0;

var just_clicked = 0; //0 or 1
var scroll_LR = 0; //-1, 0, 1
var scroll_UD = 0; //-1, 0, 1
var xClicked = 0; //x coordinate of canvas last clicked
var yClicked = 0; //y coordinate of canvas last clicked
var xSelected = -1; //x index of selected tile
var ySelected = -1; //y index of selected tile
var oSelected = -1; //selected tile offset index
var unit_selected = {}; //selected Unit object
var city_selected = {}; //selected City object
var xSelected;
var ySelected;
var oSelected;
var mouse_action = MOUSE_SELECT; //todo: chosen action to do on next click e.g. move/attack, bombard
var city_window = 0;
var cameraX = 0, cameraY = 0; //top left corner of camera (canvas coordinates)
var ctr_xs = [], ctr_ys = [];
var ctr_xs_offset = [], ctr_ys_offset = [];
var background; //canvas image
let img = new Image(); img.onload = function() {
  ctx.drawImage(img,0,0);
};

//for framerate
var filterStrength = 10;
var frameTime = 0, lastLoop = new Date, thisLoop;

//before looping, set arrays with center points
var x0 = -32 - cameraX; //x coordinate of 1st tile, moves with camera
var y0 = -32 - cameraY; //y coordinate of 1st tile, moves with camera

//center of tiles start at x0 + 0.5*w, y0 + 0.5*w
var ctr_x0 = x0 + 0.5*w;
var ctr_y0 = y0 + 0.5*w;
ctr_xs = []; //x coordinate of center of tiles, absolute coords
ctr_xs_offset = [];
ctr_ys = [];
ctr_ys_offset = [];
for (i = 0; i < numTilesX; i++) {
  ctr_xs.push(ctr_x0 + 1.41*i*w);
  ctr_xs_offset.push(ctr_x0 + 1.41*0.5*w + 1.41*i*w); //offset row
}
for (i = 0; i < numTilesY; i++) {
  ctr_ys.push(ctr_y0 + 1.41*i*w);
  ctr_ys_offset.push(ctr_y0 + 1.41*0.5*w + 1.41*i*w); //offset column
}


function drawRectRotated(_ctx,_x,_y,_w,_h,_deg) { //int, int, int, int, float, str
  //draws rectangle at _x,_y rotated around its center by _deg
  //_ctx.save(); //save ctx state
  _ctx.translate(_x ,_y);
  _ctx.rotate(0.01745*_deg); //rotate uses radians
  _ctx.translate(-_x - _w*0.5, -_y - _h*0.5);
  //_ctx.fillStyle = _color;
  _ctx.fillRect(_x + _w*0.717,_y,_w,_h);
  //_ctx.restore(); //load ctx state from last save
  ctx.setTransform(1,0,0,1,0,0); //reset transformation matrix
  return;
}

function drawRectRotatedColor(_ctx,_x,_y,_w,_h,_deg,_color) { //int, int, int, int, float, str
  //draws rectangle at _x,_y rotated around its center by _deg
  //_ctx.save(); //save ctx state
  _ctx.translate(_x ,_y);
  _ctx.rotate(0.01745*_deg);
  _ctx.translate(-_x - _w*0.5, -_y - _h*0.5);
  _ctx.fillStyle = _color;
  _ctx.fillRect(_x + _w*0.717,_y,_w,_h);
  //_ctx.restore(); //load ctx state from last save
  ctx.setTransform(1,0,0,1,0,0); //reset transformation matrix
  return;
}

function outlineRectRotated(_ctx,_x,_y,_w,_h,_deg,_color) { //int, int, int, int, float, str
  //draws rectangle at _x,_y rotated around its center by _deg
  //_ctx.save(); //save ctx state
  _ctx.translate(_x ,_y);
  _ctx.rotate(0.01745*_deg);
  _ctx.translate(-_x - _w*0.5, -_y - _h*0.5);
  _ctx.strokeStyle = _color;
  _ctx.lineWidth = 6;
  _ctx.rect(_x,_y,_w,_h);
  _ctx.strokeRect(_x + _w*0.717,_y,_w,_h);
  //_ctx.stroke();
  //_ctx.restore(); //load ctx state from last save
  ctx.setTransform(1,0,0,1,0,0); //reset transformation matrix
  return;
}

function numToColor(_r,_g,_b) { //returns html color string from 3 numbers
  return "rgb(" + Math.round(_r).toString() + "," + Math.round(_g).toString() + "," + Math.round(_b).toString() + ")";
}

function distance(_x1,_y1,_x2,_y2) { //pythagorean theorem
  var _xdif = _x2 - _x1;
  var _ydif = _y2 - _y1;
  return Math.sqrt(_xdif*_xdif + _ydif*_ydif);
}

function getXWrapped(_x,_numTilesX) { //get actual x index of wrapped tile based on number of tiles in x, no global variables hopefully improves speed
  if (_x < 0) {
    return _numTilesX+_x;
  }
  else if (_x >= _numTilesX) {
    return _x - _numTilesX;
  }
  else {
    return _x;
  }
}

function printMousePos(event) { //print canvas to log
  var _rect = canvas.getBoundingClientRect();
  console.log("clientX: " + (event.clientX - _rect.left) +
    " - clientY: " + (event.clientY - _rect.top) );
}

function onLeftClick(event) {
	leftclickevent = event;
	leftclicked = 1;
}

function onRightClick(event) {
	event.preventDefault(); //prevents the usual right click menu on a webpage
	rightclickevent = event;
	rightclicked = 1;
}

function click(event) { //left click to select unit or city
	
	var _rect = canvas.getBoundingClientRect();
  just_clicked = 1; //global
	xClicked = event.clientX - _rect.left; //global
  yClicked = event.clientY - _rect.top; //global
	//clicked on UI icon of unit  canvas.width - ui_w + 16, canvas.height - ui_h + 16 + fontsize*2
	if (xClicked > canvas.width - ui_w + 16 && xClicked < canvas.width - ui_w + 16 + 48 && yClicked > canvas.height - ui_h + 16 + fontsize_ui*2 && yClicked < canvas.height - ui_h + 16 + fontsize_ui*2 + 48) {
		if (Object.keys(unit_selected).length > 0) {
			[_y, _x] = getScreenCoordsOfTile( unit_selected.y, unit_selected.x );
			//if (_x > canvas.width || _x < 0 || _y > canvas.height || _y < 0) { //move camera to unit if off screen
				cameraY = _y + cameraY - 0.5*canvas.height;
				cameraX = _x + cameraX - 0.5*canvas.width;
			//}
			return;
		}
		else {
			selectNextUnit(civs[civ_PC]);
			return;
		}
	}
	
	
	[_yi, _xi] = selectTile(event); 
	unitsmenu(0); //close unitsmenu on left click
	if (just_used_units_menu) {just_used_units_menu = 0; return;} //left click disabled when exiting unit menu to avoid unselecting the unit you just selected
  if (mouse_action == 0) {
    //if unit on tile, select unit
    //console.log(units_map[_offset][_yi][_xi]);
		if (city_window == 0) {
			if (_yi >= 0 && units_map[_yi][_xi].length > 0) { //todo: check bounds?
				unit_selected = units_map[_yi][_xi][0];
				xSelected = _xi; ySelected = _yi;
				console.log("Selected " + unit_selected.name + " (civ " + unit_selected.civ + ")" );
			}
			else {
				unit_selected = {};
			}
			/*
			if (cities_map[_yi][_xi].length == 1) { //select city
				city_selected = cities_map[_yi][_xi][0];
				xSelected = _xi; ySelected = _yi;
				console.log("Selected " + city_selected.name + " (civ " + city_selected.civ + ")" );
				city_selected.updateCity();
				updateCityInfo(city_selected);
			}
			*/
			//else {
				if (city_selected != {}) {
					let menu = document.getElementById("contextMenu");
					if (menu.style.display != "none") {
						console.log("closing city menu");
						menu.style.display = "none";
					}
					city_selected = {};
					updateCityInfo(0);
				}
			//}
		}
		//if assigning citizens
		if (city_window == 2) { //close menu before displaying city window stuff on next frame
			city_window = 1;
		}
		else if (city_window == 1) {
			let tiles_adjacent = getAdjacentTiles(city_selected.y, city_selected.x); //tiles adjacent to city
			let _break = 0;
			let _tileSelected = -1;
			for (let i=0; i<tiles_adjacent.length; i++) {
				if (tiles_adjacent[i][0] == _yi && tiles_adjacent[i][1] == _xi) {
					_tileSelected = i;
					break;
				}
				//city_selected.tiles_worked
			}
			if (_tileSelected > -1) { //tile adjacent to city has been clicked
				if (city_selected.tiles_worked[_tileSelected] == 1) { //clicked tile is being worked by this city
					city_selected.tiles_worked[_tileSelected] = 0; //set tile to not being worked
					city_selected.entertainers += 1; //make entertainer
					city_selected.updateCity();
					updateCityInfo(city_selected);
				}
				else if (city_selected.tiles_available[_tileSelected] == 1) { //clicked tile is not being worked already and is available
					if (city_selected.entertainers >= 1) {
						city_selected.entertainers -= 1; //lose entertainer, work clicked tile
						city_selected.tiles_worked[_tileSelected] = 1;
						city_selected.updateCity();
						updateCityInfo(city_selected);
					}
				}
			}
			else {city_window = 0; updateCityInfo(0);} //close city window if click outside of adjacent tiles; todo: make it more clear that you are in city window
		}
		
		
  }

}

function isAdjacent(ySelected,xSelected,_y,_x) { //determines if (_y, _x) is adjacent to (ySelected, xSelected); todo: check if x is 0 or max
  let adjacent_tiles = getAdjacentTiles(_y,_x);
	for (let i=0; i<adjacent_tiles.length; i++) {
		if (ySelected == adjacent_tiles[i][0] && xSelected == adjacent_tiles[i][1]) {
			return 1;
		}
	}
	return 0;
}

function rightclick(event) {
	//event.preventDefault(); //prevents the usual right click menu on a webpage
	[_y,_x] = selectTile(event); //index of clicked tile
	
	//if ( ySelected >= 0 && cities_map[ySelected][xSelected].length == 1 && Object.keys(city_selected).length > 0) { //if city is on the left-clicked tile
	if ( cities_map[_y][_x].length > 0 ) { //if right click on tile with city
		if (Object.keys(unit_selected).length === 0) { //no unit selected
			//select city
			city_selected = cities_map[_y][_x][0];
			ySelected = _y; xSelected = _x;
			if ( cities_map[ySelected][xSelected][0].civ == civ_PC ) { //player can only do stuff with own city
				if ( _y == ySelected && _x == xSelected ) {
					cities_map[ySelected][xSelected][0].citymenu(1,event); //open city menu for right click on same tile
					updateCityInfo(city_selected);
				}
			}
		}
		else { //unit selected on city
			showUnitsOnTile(_y,_x, event); //show all units on tile
			update_background = 1;
			return;
		}
			
	}
	
	//if unit is selected, try to move to right-clicked tile
	if (Object.keys(unit_selected).length === 0 || (unit_selected.x === _x && unit_selected.y === _y) ) { //if no unit selected or right clicked on selected unit
		if ( cities_map[_y][_x].length === 0 ) { //no city on tile
			showUnitsOnTile(_y,_x, event); //show all units on tile
			update_background = 1;
			return;
		}
	}
	
	if ( ySelected >= 0 && unit_selected != {} ) { //if unit is on the left-clicked tile
		if ( unit_selected.civ == civ_PC ) { //player can only move their own units, xSelected is of selected unit
			if (unit_selected.movesleft < 1) {console.log("no moves left");} //if unit has no moves left
			else {
				if ( isAdjacent(ySelected,xSelected,_y,_x) ) { //only allow one tile at a time; todo: pathing over multiple moves
					//if move is allowed
					_moveaction = getMoveAction(_y, _x, unit_selected.civ); //0 for nothing allowed, 1 for move, 2 for attack
					if ( _moveaction == 1 ) { //if no units or buildings on tile, or unit's civ controls tile
						//_ind = units_map[ySelected][xSelected].findIndex( object => {return object.id === unit_selected.id;} ) //get index of selected unit in array of units on selected tile;
						units_map[ySelected][xSelected].splice(0, 1); //remove selected unit (moved to front of index when selected from stack) from old tile
						units_map[_y][_x].push(unit_selected); //put unit at new tile
						unit_selected.x = _x; unit_selected.y = _y; //update unit x,y position
						unit_selected.movesleft -= 1; //decrease movement point; todo: take terrain into account
						if (unit_selected.movesleft <= 0) { //if unit has no moves left
							//auto-select next unit
							let foundunit = 0;
							for (let i=0; i<civs[unit_selected.civ].units.length; i++) {
								if (civs[unit_selected.civ].units[i].movesleft > 0) {
									unit_selected = civs[unit_selected.civ].units[i];
									xSelected = unit_selected.x; ySelected = unit_selected.y;
									foundunit = 1;
									break;
								}
							}
							if (foundunit === 0) { unit_selected = {}; } //unselect unit
						}
					}
					else if ( _moveaction == 2 ) { //attack
						console.log("fighting");
						//get opponent
						let defender = getDefender(units_map[_y][_x]); //list of units on tile being attacked
						//combat
						combat_result = combat(unit_selected, defender); //attacker, defender; returns int
						if (combat_result === 1) {
							//1: attacker wins
							//delete defender
							defender.remove();
							//if no units left on defending tile, move attacker to that tile
							if (units_map[_y][_x].length === 0) {
								//_ind = units_map[ySelected][xSelected].findIndex( object => {return object.id === unit_selected.id;} ) //get index of selected unit in array of units on selected tile;
								units_map[ySelected][xSelected].splice(0, 1); //remove selected unit (moved to front of index when selected from stack) from old tile
								units_map[_y][_x].push(unit_selected); //put unit at new tile
								unit_selected.x = _x; unit_selected.y = _y; //update unit x,y position
								unit_selected.movesleft -= 1; //decrease movement point; todo: take terrain into account
								if (unit_selected.movesleft <= 0) { //if unit has no moves left
									//auto-select next unit
									let foundunit = 0;
									for (let i=0; i<civs[unit_selected.civ].units.length; i++) {
										if (civs[unit_selected.civ].units[i].movesleft > 0) {
											unit_selected = civs[unit_selected.civ].units[i];
											xSelected = unit_selected.x; ySelected = unit_selected.y;
											foundunit = 1;
											break;
										}
									}
									if (foundunit === 0) { unit_selected = {}; } //unselect unit
								}
							}
						}
						else if (combat_result === 0) {
							//0: defender wins
							//delete attacker
							unit_selected.remove();
							
							//auto-select next unit
							let foundunit = 0;
							for (let i=0; i<civs[unit_selected.civ].units.length; i++) {
								if (civs[unit_selected.civ].units[i].movesleft > 0) {
									unit_selected = civs[unit_selected.civ].units[i];
									xSelected = unit_selected.x; ySelected = unit_selected.y;
									foundunit = 1;
									break;
								}
							}
							if (foundunit === 0) { unit_selected = {}; } //unselect unit
							
						}
					}
				}
				update_background = 1;
				return;
			}
		} 
	}



}

function selectNextUnit(_civ) {
	//auto-select next unit
	let foundunit = 0;
	for (let i=0; i<_civ.units.length; i++) {
		if (_civ.units[i].movesleft > 0) {
			unit_selected = _civ.units[i];
			xSelected = unit_selected.x; ySelected = unit_selected.y;
			foundunit = 1;
			break;
		}
	}
	if (foundunit === 0) { unit_selected = {}; } //unselect unit
}

function onKeydown(event) {
	keypressedonce = event.key; //global
}

function selectTile(event) { //returns array with: x index of tile, y index of tile, whether tile is inline (1) or offset (0); requires some global vars: canvas, ctr_xs, ctr_ys, ctr_xs_offset, ctr_ys_offset
  //todo: calculation of distance from center of tiles is not quite right
	var _rect = canvas.getBoundingClientRect();
  just_clicked = 1; //global
  xClicked = event.clientX - _rect.left; //global
  yClicked = event.clientY - _rect.top; //global
	
	//compare clicked coordinates to center of each tile on the screen, copied from code that draws tiles each loop
	
	let x0 = -cameraX - w/2;
	let y0 = -cameraY - w/2;
	let xstart = 0;
	let xend = numTilesX;
	if (wrapX == 1) { //scrolling to left or right will wrap back around to the other side
    xstart = -30; //draw extra tiles in x so x wraps around. The camera will reset when you get to the end of the extra tiles on either side
    xend = numTilesX + 1 + Math.round(canvas_width/(1.41*w));
  }
	
	//let color = numToColor(255, 255, 255);
	let w2 = w*w;
	const closest_dists = [];
	const closest_xs = [];
	const closest_ys = [];
	for (let xi = xstart; xi < xend; xi++) {
		let x = getXWrapped(xi, numTilesX); //x coordinate of tile in top row
		for (let y = 0; y < numTilesY; y++) {
			let _tileX = x0 + xi*w*1.41 + y*w*0.5*1.41;
			let _tileY = y0 + y*w*0.5*1.41;
			if (_tileX > -w*1.41 && _tileX < canvas_width+w*1.41 && _tileY > -w*1.41 && _tileY < canvas_height + w*1.41) { //only consider tiles on screen  
				//drawRectRotatedColor(ctx, _tileX, _tileY, 4, 4, 0.0, color);
				let xdist = (xClicked - _tileX)*(xClicked - _tileX);
				let ydist = (yClicked - _tileY)*(yClicked - _tileY);
				if (xdist < w2 && ydist < w2) {
					closest_dists.push((xdist + ydist)**0.5);
					closest_xs.push(x);
					closest_ys.push(y);
				}
				
			}
		}
	}
	let dmin = w; //shortest distance so far
	let imin = -1; //index of shortest distance so far
	for (let i=0; i<closest_dists.length; i++) { //find smallest distance
		if (closest_dists[i] < dmin) {
			dmin = 0
			imin = i;
		}
	}
	//console.log("Clicked tile (x,y): " + closest_xs[imin] + "," + closest_ys[imin]);

  return [closest_ys[imin], closest_xs[imin]]; //[y,x] index of closest tile
  //this array can be used for outlining selected tile, doing stuff to tile, or just getting indices of selected tile
}

function onMouseMove(event) { //scrolls screen when moused over edge
  var scrollZone = 48; //number of pixels from edge to scroll
  let _rect = canvas.getBoundingClientRect();
  xMouse = event.clientX; // - _rect.left;
  yMouse = event.clientY; // - _rect.top;
  if (xMouse < _rect.left && xMouse > 4) { //if mouse is to left of canvas but not all the way at edge
    scroll_LR = -1; //global
  }
  else if (xMouse > _rect.right && xMouse < _rect.right + scrollZone) {
    scroll_LR = 1;
  }
  else {
    scroll_LR = 0;
  }
  if (yMouse < _rect.top && yMouse > _rect.top - scrollZone) { //if mouse is to left of canvas
    scroll_UD = -1; //global
  }
  else if (yMouse > _rect.bottom && yMouse < _rect.bottom + scrollZone/2) {
    scroll_UD = 1;
  }
  else {
    scroll_UD = 0;
  }
	
	//get tile being moused over
	[mouseover_y_new,mouseover_x_new] = selectTile(event);
	//console.log(mouseover_x_new, mouseover_y_new);
	//if (mouseover_y_new != mouseover_y && mouseover_x_new != mouseover_x) {
		mouseover_y = mouseover_y_new; mouseover_x = mouseover_x_new;
		update_background = 1;
	//}
}

function getMoveAction(_y,_x,_civid) { //check if tile (_y,_x) can be moved to by a unit from civ _civid
	if ( units_map[_y][_x].length == 0 && cities_map[_y][_x].length == 0 ) { //empty tile
		return 1;
	}
	else {
		if (units_map[_y][_x].length == 0) { //city only, no units on tile
			if ( cities_map[_y][_x][0].civ == _civid) { //same civ
				return 1;
			}
			else {
				return 2;
			}
		}
		else {
			if ( units_map[_y][_x][0].civ == _civid ) { //unit on tile (with or without city)
				return 1;
			}
			else {
				return 2;
			}
		}
	}
	//return 1 for move allowed, 2 for fight, 0 for not allowed
}

function getAdjacentTiles(_y,_x) { //from tile index (y,x), get array of adjacent tiles, starting from NE -> clockwise; todo: make work for first or last tiles in x,y
	_tilesAdjacent = [];
	_tilesAdjacent.push([_y-1,_x+1]);
	_tilesAdjacent.push([_y,_x+1]);
	_tilesAdjacent.push([_y+1,_x]);
	_tilesAdjacent.push([_y+2,_x-1]);
	_tilesAdjacent.push([_y+1,_x-1]);
	_tilesAdjacent.push([_y,_x-1]);
	_tilesAdjacent.push([_y-1,_x]);
	_tilesAdjacent.push([_y-2,_x+1]);
	return _tilesAdjacent;
}

function unitsmenu(open, _y=-1, _x=-1, e=null) {
	if (open == 1) {
		let list = document.getElementById("unitsontile");
		list.innerHTML = "";
		//add list elements to menu
		for (let i=0; i<units_map[_y][_x].length; i++) {
			let li = document.createElement("li");
			let _unit = units_map[_y][_x][i];
			li.innerText = _unit.name;
			li.setAttribute("onclick", "selectUnit(" + _y + "," + _x + "," + i + ")");
			list.appendChild(li);
		}
		
		let menu = document.getElementById("contextMenu_units");
		menu.style.display = "block";
		menu.style.left = e.pageX + "px";
		menu.style.top = e.pageY + "px"; 
	}
	else {
		console.log("closing units menu");
		let menu = document.getElementById("contextMenu_units");
		menu.style.display = "none";
	}
}

function selectUnit(_y, _x, i) { //todo: sometimes units are duplicated when moved after being selected from this function
	//move selected unit to front of array
	units_map[_y][_x].unshift(units_map[_y][_x].splice(i, 1)[0]);
	//selected unit is now at index 0
	unit_selected = units_map[_y][_x][0]; //global
	xSelected = _x; ySelected = _y;
	just_used_units_menu = 1; //after clicking on units menu, disable other click actions on same frame
}

function showUnitsOnTile(_y,_x, e) {

	if (units_map[_y][_x].length <= 1) {
		return; //if only one unit, don't show menu
	}

	unitsmenu(1,_y,_x,e);
	//just_used_units_menu = 1; //after clicking on units menu, disable other click actions on same frame
	
}

function setProduction(n) {
	city_selected.setProduction(n);
}

function assignCitizens() {
	city_selected.citymenu(0);
	city_window = 2; //set to 1 after clicking on menu
}

function updateCityInfo(_city) { //_city is a City object; update the html to show city info
	if (_city === 0) {
		city_selected = {};
		cityinfo.innerHTML = "No city selected";
	}
	else {
		cityinfo.innerHTML = _city.name + "<br>" + "producing: " + _city.making + "<br> happy: " + _city.happy + ", content: " + _city.content + ", angry: " + _city.angry + ", entertainers: " + _city.entertainers + "<br> food: +" + _city.food + " (" + _city.food_stored + "/" + _city.food_to_grow + "), shields: +" + _city.shields + " (" + _city.shields_stored + "/" + _city.shields_to_make + "), trade: " + _city.trade;
	}
}

function drawCitizens() {
	//console.log(xSelected + ", " + ySelected);

	const tiles_adjacent = getAdjacentTiles(city_selected.y, city_selected.x); //coordinates of available tiles (o,x,y)

	let _foodvals = []; //same length of _tilesAvailable
	let _shieldvals = [];
	let _tradevals = [];
	for (let i = 0; i < tiles_adjacent.length; i++) { //loop over adjacent tiles
		let _x = tiles_adjacent[i][1];
		let _y = tiles_adjacent[i][0];
		
		_foodvals.push(terrain_map[_y][_x].food);
		_shieldvals.push(terrain_map[_y][_x].shield);
		_tradevals.push(terrain_map[_y][_x].trade);
		
		//draw stuff here
		if (city_selected.tiles_available[i] == 0) { //tile not available gets black square
			[_yScreen,_xScreen] = getScreenCoordsOfTile(_y, _x);
			ctx.fillStyle = "black";
			drawRectRotated(ctx, _xScreen + 0.2*w, _yScreen + w/2, w/4, w/4, 0.0);	
		}
		if (city_selected.tiles_worked[i] == 1) { //tile worked by this city gets blue square
			[_yScreen,_xScreen] = getScreenCoordsOfTile(_y, _x);
			ctx.fillStyle = "blue";
			drawRectRotated(ctx, _xScreen + 0.2*w, _yScreen + w/2, w/4, w/4, 0.0);
		}
	}
	ctx.fillStyle = "green"; //reset fill color
}

function getScreenCoordsOfTile(y,xi) { //from tile index, get center of tile in screen coords for drawing
	if (xi > numTilesX - canvas.width/(w*1.41) && cameraX < canvas.width) {xi -= numTilesX;} //unwrap x
	let _tileX = x0 + xi*w*1.41 + y*w*0.5*1.41 - cameraX;
	let _tileY = y0 + y*w*0.5*1.41 - cameraY;
	return [_tileY,_tileX];
}

function endTurn(_civ) { //end turn for _civ
  //unselect unit and city
	updateCityInfo(0);
	for (let i = 0; i < _civ.units.length; i++) { //loop over civ's units
    _civ.units[i].movesleft = _civ.units[i].moves; //reset unit moves
  }
	for (let i = 0; i < _civ.cities.length; i++) { //loop over civ's cities
		_civ.cities[i].updateCity();
		
		//food
		_civ.cities[i].food_stored += _civ.cities[i].food;
		if (_civ.cities[i].food_stored >= _civ.cities[i].food_to_grow) { //grow
			_civ.cities[i].food_stored -= _civ.cities[i].food_to_grow;
			_civ.cities[i].population += 1;
			let foundtile = 0;
			for (let j=0; j<_civ.cities[i].tiles_worked.length; j++) {
				if (_civ.cities[i].tiles_worked[j] === 0) {
					_civ.cities[i].tiles_worked[j] = 1;
					foundtile = 1;
					break;
				}
			}
			if (foundtile === 0) {_civ.cities[i].entertainers += 1;}
		}
		else if (_civ.cities[i].food_stored < 0) { //starve
			_civ.cities[i].food_stored = 0;
			_civ.cities[i].population -= 1;
			let foundtile = 0;
			for (let j=0; j<_civ.cities[i].tiles_worked.length; j++) {
				if (_civ.cities[i].tiles_worked[j] === 1) {
					_civ.cities[i].tiles_worked[j] = 0;
					foundtile = 1;
					break;
				}
			}
			if (foundtile === 0) {_civ.cities[i].entertainers -= 1;}
		}
		
		//shields
		_civ.cities[i].shields_stored += _civ.cities[i].shields;
		//make stuff with shields
		if (_civ.cities[i].shields_stored >= _civ.cities[i].shields_to_make) {
			if ( _civ.cities[i].population <= getPopcost(_civ.cities[i].making) ) { //check if population is high enough to make unit like settler or worker
				_civ.cities[i].shields_stored = _civ.cities[i].shields_to_make - 1; //keep shields at cost of unit - 1
			}
			else { //make thing when there are enough shields and population
				switch (getMakingType(_civ.cities[i].making)) {
					//make unit
					case "military_land":
					case "military_water":
					case "settler":
					case "worker":
						let _newunit = new Unit(_civ.cities[i].making, _civ.id);
						units_map[_civ.cities[i].y][_civ.cities[i].x].push(_newunit)
						_civ.units.push(_newunit)
						//
						break;
					//make building
					case "building":
						_civ.cities[i].buildings.push(_civ.cities[i].making);
						break;
					//make wonder
					case "wonder":
						_civ.cities[i].wonders.push(_civ.cities[i].making);
						break
				}
				_civ.cities[i].shields_stored = 0; //reset shields to 0 after making thing
				_civ.cities[i].population -= getPopcost(_civ.cities[i].making); //lose population if thing costs population
			}
		}
		
		//trade
		_civ.gold += _civ.taxrate*_civ.cities[i].trade;
		_civ.science += _civ.sciencerate*_civ.cities[i].trade
		//todo: corruption	
	}
	
	//increment turn counter
	turn += 1;
	
	//auto-select unit for player
	if (_civ.id === civ_PC) {
		unit_selected = civs[civ_PC].units[0];
		xSelected = unit_selected.x; ySelected = unit_selected.y;
	}
	
	//update html
	turninfo.innerHTML = "Turn: " + turn;
}

function getMakingType(_string) { //is thing being made by city a unit, building, wonder, etc?
	if (_string === "Settler") {return "settler";}
	if (_string === "Worker") {return "worker";}
	if (_string === "Wealth") {return "wealth";}
	//units
	if ( ["Warrior", "Archer", "Chariot", "Horseman"].includes(_string) ) {
		return "military_land";
	}
	if ( ["Temple", "Barracks"].includes(_string) ) {
		return "building";
	}
	if ( ["Pyramids"].includes(_string) ) {
		return "wonder";
	}
}

function getShieldcost(_string) {
	if (_string === "Settler") {return 30;}
	if (_string === "Worker") {return 10;}
	if (_string === "Warrior") {return 10;}
	if (_string === "Wealth") {return 0;}
}

function getPopcost(_string) { //population cost of unit
	if (_string === "Settler") {return 2;}
	if (_string === "Worker") {return 1;}
	else {return 0;}
}

function recolorModel(_model, _civ) { //_model is in models, _civ is Civ object
		//change some pixel values to get different colors

		// create a destination canvas. Here the altered image will be placed
		//var dstCanvas = document.createElement("canvas");
		//dstCanvas.width = _model.width;
		//dstCanvas.height = _model.height;

		// append the canvas elements to the container
		//document.getElementById('container').appendChild(srcCanvas);
		//document.getElementById('container').appendChild(dstCanvas);

		// get context to work with
		let srcCanvas = document.createElement("canvas");
		srcCanvas.width = _model.width;
		srcCanvas.height = _model.height;
		let srcContext = srcCanvas.getContext("2d");
		//var dstContext = dstCanvas.getContext("2d");

		// draw the loaded image on the source canvas
		srcContext.drawImage(_model, 0, 0);

		// read pixels from source
		var pixels = srcContext.getImageData(0, 0, _model.width, _model.height);

		// iterate through pixel data (1 pixels consists of 4 ints in the array)
		for(var i = 0, len = pixels.data.length; i < len; i += 4){
				var r = pixels.data[i];
				var g = pixels.data[i+1];
				var b = pixels.data[i+2];

				// if the pixel matches color, set alpha to 0
				if(r == 255 && g == 0 && b == 255){
						pixels.data[i] = _civ.r;
						pixels.data[i+1] = _civ.g;
						pixels.data[i+2] = _civ.b;
				}
		}

		// write pixel data to destination context
		srcContext.putImageData(pixels, 0, 0);
		
		var imgnew = document.createElement("IMG");
		//imgnew.id = _model.id + _civ.id; 
		//console.log(_model.id + _civ.id);
		//let img = document.getElementById(_model.id + _civ.id);
		imgnew.src = srcCanvas.toDataURL();
		models[_model.id + _civ.id] =  imgnew;
		
}

function getDefender(units) { //get defender from array of Units when attacked
	for (let i=0; i<units.length; i++) {
		units[i];
	}
	return units[0]; //for now, just pick first unit
}

function combat(attacker, defender) { //args: attacker, defender (Unit objects); return 1 for attacker win, 0 for defender win
	let atk = attacker.atk;
	let def = defender.def;
	while (attacker.hpleft > 0 || defender.hpleft > 0) { //keep fighting until someone's hp reaches 0
		if (Math.random() < atk/(atk+def)) {
			defender.hpleft -= 1;
		}
		else {
			attacker.hpleft -= 1;
		}
	}
	if (defender.hpleft <= 0) {
		return 1;
	}
	else if (attacker.hpleft <= 0) {
		return 0;
	}
}


function loop() {
if (running === 0) {return;}
update_background = 1;

//check camera bounds
if (wrapX == 1) { //if wrapping around x, jump camera to other side of map when it reaches one end
  if (cameraX < -canvas_width) {
    cameraX = cameraX + 1.41*w*numTilesX; //move camera to less than canvas_width
  }
  else if (cameraX > 0.5*w + 1.41*w*numTilesX) { //move camera to greater than -canvas_width
    cameraX = cameraX - 1.41*w*numTilesX;
 }
}
else { //if not wrapping around x, stop camera from scrolling when too far off map
  if (cameraX < -1.41*w) {
    cameraX = -1.41*w;
    scroll_LR = 0;
  }
  else if (cameraX > (1+numTilesX)*1.41*w - canvas_width) {
    cameraX = (1+numTilesX)*1.41*w - canvas_width;
    scroll_LR = 0;
  }
}
//prevent camera from moving too far in y
if (cameraY < -1.41*w) {
  cameraY = -1.41*w;
  scroll_UD = 0;
}
else if (cameraY > 0.5*(1+numTilesY)*1.41*w - canvas_height) {
  cameraY = 0.5*((1+numTilesY)*1.41*w) - canvas_height;
  scroll_UD = 0;
}



if (scroll_LR != 0) {
  cameraX += scroll_rate*scroll_LR;
  update_background = 1;
}
if (scroll_UD != 0) {
  cameraY += scroll_rate*scroll_UD;
  update_background = 1;
}

var x0 = -32 - cameraX; //x coordinate of 1st tile, moves with camera
var y0 = -32 - cameraY; //y coordinate of 1st tile, moves with camera

//do stuff for keypresses
if (keypressedonce === "b") {
	if (unit_selected.type === "settler" && unit_selected.movesleft >= 1) {
		unit_selected.buildCity();
	}
}
//after stuff is done, reset variable
keypressedonce = "none";

//do stuff for left click
if (leftclicked) {
	click(leftclickevent); //function onLeftClick sets leftclickevent and leftclicked (1 if clicked)
}
//after stuff is done, reset variable
leftclicked = 0;

//do stuff for right click
if (rightclicked) {
	rightclick(rightclickevent); //function onLeftClick sets leftclickevent and leftclicked (1 if clicked)
}
//after stuff is done, reset variable
rightclicked = 0;

//draw tiles, only if background changed
if (update_background == 1) {

  //center of tiles start at x0 + 0.5*w, y0 + 0.5*w
  ctr_x0 = x0 + 0.5*w;
  ctr_y0 = y0 + 0.5*w;
  for (let i = 0; i < numTilesX; i++) {
    ctr_xs[i] = ctr_x0 + 1.41*i*w;
  }
  //for (let i = 0; i < numTilesY; i++) {
  //  ctr_ys[i] = ctr_y0 + 1.41*i*w;
  //}

  var xstart = 0
  var xend = numTilesX
  if (wrapX == 1) { //scrolling to left or right will wrap back around to the other side
    xstart = -30; //draw extra tiles in x so x wraps around. The camera will reset when you get to the end of the extra tiles on either side
    xend = numTilesX + 1 + Math.round(canvas_width/(1.41*w));
  }

  ctx.clearRect(0, 0, canvas_width, canvas_height);
  
  //draw rectangle in back
  //ctx.fillStyle = "red";
  //ctx.fillRect(10,10,25,40); //temp
  //ctx.fill(); //temp
  
  //ctx.fillStyle = "green";
	for (let xi = xstart; xi < xend; xi++) {
		let x = getXWrapped(xi, numTilesX); //x coordinate of tile in top row
		//let xcolor = 255*(x/numTilesX);
		for (let y = 0; y < numTilesY; y++) {
			//let ycolor = 255*(y/numTilesY);
			//var color = numToColor(ycolor, xcolor, 40);
			let _tileX = x0 + xi*w*1.41 + y*w*0.5*1.41;
			let _tileY = y0 + y*w*0.5*1.41;
			if (_tileX > -w*1.41 && _tileX < canvas_width+w*1.41 && _tileY > -w*1.41 && _tileY < canvas_height + w*1.41) { //only draw tiles on screen  
        
				//shade tiles outside city if in city window
				if (city_window == 1) {
					if ( !isAdjacent(city_selected.y, city_selected.x, y, x) ) {
						drawRectRotatedColor(ctx, _tileX, _tileY, w, w, 45.0, numToColor(terrain_map[y][x].r/5, terrain_map[y][x].g/5, terrain_map[y][x].b/5) );
					}
					else {
						drawRectRotatedColor(ctx, _tileX, _tileY, w, w, 45.0, terrain_map[y][x].color );
					}
				}			
				else { //draw normally (colored by terrain type)
					drawRectRotatedColor(ctx, _tileX, _tileY, w, w, 45.0, terrain_map[y][x].color );
				}
				
				//outline moused over tile
				if (x === mouseover_x && y === mouseover_y) {
					//console.log(x,y);
					outlineRectRotated(ctx, _tileX, _tileY, w, w, 45.0, "white");
				}
   
      }
		}
	}
	
	//loop again and draw cities
	for (let xi = xstart; xi < xend; xi++) {
	let x = getXWrapped(xi, numTilesX); //x coordinate of tile in top row
		for (let y = 0; y < numTilesY; y++) {
			let _tileX = x0 + xi*w*1.41 + y*w*0.5*1.41;
			let _tileY = y0 + y*w*0.5*1.41;
			if (_tileX > -w*1.41 && _tileX < canvas_width+w*1.41 && _tileY > -w*1.41 && _tileY < canvas_height + w*1.41) { //only draw tiles on screen  
        
				if (cities_map[y][x].length > 0) {
					if (cities_map[y][x][0] === city_selected ) {
						ctx.fillStyle = civs[city_selected.civ].highlight(); //flag
					}
					else {
						ctx.fillStyle = civs[cities_map[y][x][0].civ].color; //flag highlighted
					}
					drawRectRotated(ctx, _tileX + 0.2*w + w/2, _tileY + w/4, w/4, w/2, 15.0);
					ctx.fillStyle = "gray";
					drawRectRotated(ctx, _tileX + 0.2*w, _tileY + w/2, w/2, w/2, 0.0);
					ctx.fillStyle = "white"; //reset fill color
					//label city with name and population
					let fontsize = 12;
					ctx.font = fontsize + "px Arial";
					ctx.fillText(cities_map[y][x][0].name + " (" + cities_map[y][x][0].population + ")", _tileX, _tileY - 2*fontsize);
					ctx.fillText(cities_map[y][x][0].making + " in " + Math.ceil((cities_map[y][x][0].shields_to_make - cities_map[y][x][0].shields_stored)/cities_map[y][x][0].shields)  + " turns", _tileX, _tileY - fontsize);
					if (cities_map[y][x][0].food >= 1) {
						ctx.fillText("grows in " + Math.ceil((cities_map[y][x][0].food_to_grow - cities_map[y][x][0].food_stored)/cities_map[y][x][0].food) + " turns", _tileX, _tileY);
					}
					else if (cities_map[y][x][0].food == 0) {
						ctx.fillText("not growing", _tileX, _tileY);
					}
					else if (cities_map[y][x][0].food <= 0) {
						ctx.fillText("starves in " + Math.floor(1 - cities_map[y][x][0].food_stored/cities_map[y][x][0].food) + " turns", _tileX, _tileY);
					}
				}
			}
		}
	}
	
	//loop again and draw units
	for (let xi = xstart; xi < xend; xi++) {
	let x = getXWrapped(xi, numTilesX); //x coordinate of tile in top row
		for (let y = 0; y < numTilesY; y++) {
			let _tileX = x0 + xi*w*1.41 + y*w*0.5*1.41; //screen x coordinate of tile
			let _tileY = y0 + y*w*0.5*1.41; //screen y coordinate of tile
			if (_tileX > -w*1.41 && _tileX < canvas_width+w*1.41 && _tileY > -w*1.41 && _tileY < canvas_height + w*1.41) { //only draw tiles on screen  
       
        if (units_map[y][x].length > 0) { //if units_map array at tile has units in it, draw
					//highlight selected unit
					if (units_map[y][x][0] === unit_selected ) {
						//ctx.fillStyle = civs[unit_selected.civ].highlight();
						units_map[y][x][0].drawHighlighted(_tileX, _tileY);
					}
					else { //if not selected, draw normally
					
						//ctx.fillStyle = civs[units_map[y][x][0].civ].color;	
						//drawRectRotated(ctx, _tileX + 0.2*w, _tileY + w/2, w/4, w/4, 0.0);
						
						units_map[y][x][0].draw(_tileX, _tileY); //draw unit
						
						//if more than one unit on tile, label how many
						if (units_map[y][x].length >= 2) {
							let fontsize = 12;
							ctx.font = fontsize + "px Arial";
							ctx.fillStyle = "white";
							ctx.fillText(units_map[y][x].length, _tileX, _tileY);
						}

						//ctx.drawImage(model_Warrior,_tileX + 0.1*w, _tileY);
						//ctx.fillStyle = "green"; //reset fill color
					}
        } 
			}
		}
	}
	
	
	//draw UI
	ctx.fillStyle = "gray";
	ctx.fillRect(canvas.width - ui_w, canvas.height - ui_h, ui_w, ui_h);
	ctx.strokeStyle = "black";
	ctx.strokeRect(canvas.width - ui_w, canvas.height - ui_h, ui_w, ui_h);
	
	ctx.font = fontsize_ui + "px Arial";
	ctx.fillStyle = "black";
	ctx.fillText("gold: " + parseFloat(civs[civ_PC].gold).toFixed(1) + ", science: " + parseFloat(civs[civ_PC].science).toFixed(1), canvas.width - ui_w + 16, canvas.height - ui_h + 16);



	if (Object.keys(unit_selected).length > 0) { //unit selected
		ctx.fillText("selected: " + unit_selected.name + ", hp: " + unit_selected.hpleft + "/" + unit_selected.hp + ", moves: " + unit_selected.movesleft + "/" + unit_selected.moves, canvas.width - ui_w + 16, canvas.height - ui_h + 16 + fontsize_ui);
		//draw unit's icon
		unit_selected.draw(canvas.width - ui_w + 16, canvas.height - ui_h + 16 + fontsize_ui*2);
	}
	else {
		ctx.fillText("select next unit", canvas.width - ui_w + 16, canvas.height - ui_h + 16 + fontsize_ui*3);
	}
	

	//city window
	if (city_selected === {}) {
		city_window = 0;
	}
	if (city_window == 1) {
		drawCitizens();
	}
 
  //save background
  background = canvas.toDataURL()
}
else { //draw saved background
  img.src = background;
}

//framerate
var thisFrameTime = (thisLoop=new Date) - lastLoop;
frameTime += (thisFrameTime - frameTime) / filterStrength;
lastLoop = thisLoop;


/*
//center dots
for (y = 0; y < 6; y++) {
  for (x = 0; x < 8; x++) {
    //center coordinate of each tile
    var centers = [x0 + 0.5*w + 1.41*x*w, y0 + 0.5*w + 1.41*y*w];
    ctx.fillStyle = "blue";
    ctx.fillRect(x0 + 0.5*w + 1.41*x*w,y0 + 0.5*w + 1.41*y*w,4,4);
  }
}
//center dots, offset
for (y = 0; y < 6; y++) {
  for (x = 0; x < 8; x++) {
    //center coordinate of each tile 
    var centers_offset = [x0 + 0.5*w + 1.41*0.5*w + x*w*1.41, y0 + 0.5*w + 1.41*0.5*w + y*w*1.41];
    ctx.fillStyle = "purple";
    ctx.fillRect(x0 + 0.5*w + 1.41*0.5*w + x*w*1.41, y0 + 0.5*w + 1.41*0.5*w + y*w*1.41,4,4);
  }
*/


update_background = 0;

}


//document.addEventListener("click", selectTile);
document.addEventListener("click", onLeftClick);
document.addEventListener('contextmenu', onRightClick);
document.addEventListener("mousemove", onMouseMove);
document.addEventListener("focusout", (event) => {scroll_LR = 0; scroll_UD = 0}); //when not focused on this page, don't scroll
document.addEventListener("keydown", onKeydown);



//set up unit models colored by civ
for (let i=0; i < civs.length; i++) {
	//these models have been added in the html, new elements from recolorModel used in Unit.draw()
	recolorModel(model_Warrior, civs[i]);
	recolorModel(model_Settler, civs[i]);
	recolorModel(model_Worker, civs[i]);
}


running = 1;

//game loop
setInterval(loop,30); //run game loop every 30 ms



setInterval(function(){ //update fps text every 1000 ms
  fpsOut.innerHTML = (1000/frameTime).toFixed(1) + " fps";
},1000);


//todo: combat
//todo: trade, tech
//todo: terrain generation

</script>